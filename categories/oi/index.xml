<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>OI - 分类 - Cyan&#39;s Notebook</title>
    <link>/categories/oi/</link>
    <description>OI - 分类 - Cyan&#39;s Notebook</description>
    <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 21 May 2022 18:57:41 &#43;0800</lastBuildDate><atom:link href="/categories/oi/" rel="self" type="application/rss+xml" /><item>
  <title>动态规划</title>
  <link>/posts/dp/</link>
  <pubDate>Sat, 21 May 2022 18:57:41 &#43;0800</pubDate>
  <author>Cyan</author>
  <guid>/posts/dp/</guid>
  <description><![CDATA[<h2 id="动规解题的一般思路">动规解题的一般思路</h2>
<p><strong>将原问题分解为子问题</strong></p>
<p>把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。子问题都解决，原问题即解决(数字三角形例）。
子问题的解一旦求出就会被保存，所以每个子问题只需求解一次。</p>]]></description>
</item>
<item>
  <title>Python OI 基础（语言篇）</title>
  <link>/posts/python-oi-basis/</link>
  <pubDate>Fri, 08 Apr 2022 22:44:06 &#43;0800</pubDate>
  <author>Cyan</author>
  <guid>/posts/python-oi-basis/</guid>
  <description><![CDATA[基本 输入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def cin1(): return [int(i) for i in input().split()] def cin2(): return map(int, input().split()) def cin3(): return list(map(int, input().split())) # 输入一个常数 n, = cin() # 注意&#39;,&#39; m, n = cin() # 输入一个数组 arr = cin() # 注意cin2会返回map对象 输入输出重定向 使用操作系统的重定向
1 python script.py &lt; input &gt; output Python 与 STL Python 标准库 — Python 3.]]></description>
</item>
<item>
  <title>背包问题</title>
  <link>/posts/knapsack-problem/</link>
  <pubDate>Fri, 08 Apr 2022 21:35:22 &#43;0800</pubDate>
  <author>Cyan</author>
  <guid>/posts/knapsack-problem/</guid>
  <description><![CDATA[<h2 id="前言">前言</h2>
<p>在21年我第一次学习动态规划算法的时候，HQ学长安排的入门题目即是背包。直至前不久我只把背包当成一种有限的题目来看，未想还有如此讲究。</p>
<p><strong>实际上，有很多问题可以规约为一个背包问题。</strong></p>]]></description>
</item>
<item>
  <title>素数</title>
  <link>/posts/prime-number/</link>
  <pubDate>Mon, 17 Jan 2022 14:09:06 &#43;0800</pubDate>
  <author>Cyan</author>
  <guid>/posts/prime-number/</guid>
  <description><![CDATA[检验 1 2 3 4 5 6 7 8 9 10 from math import * def is_prime(n): if n &lt; 2: return False for i in range(2, int(sqrt(n))+1): if n % i == 0: return False return True 打表(欧式筛法) 0、1不是素数，素数的倍数不是素数（质因数分解）
1 2 3 4 5 6 7 8 9 def prime(MAX_N): lst = [True for _ in range(MAX_N+1)] lst[0] = lst[1] = False for i in range(2, MAX_N//2): if lst[i]: for j in range(2*i, MAX_N+1, i): lst[j] = False return lst 1 2 3 4 5 6 7 8 9 10 11 12 13 #define MAX 10005 bool prime[MAX]; void init_prime(){ memset(prime,true,sizeof(prime)); prime[0]=prime[1]=false; for(int i=2;i&lt;=MAX/2;i++){ if(!]]></description>
</item>
</channel>
</rss>
